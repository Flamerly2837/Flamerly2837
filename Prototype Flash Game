<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TileCraft - Strategy Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            text-align: center;
            color: #f39c12;
            font-size: 2.5em;
            margin-bottom: 20px;
        }
        .game-info {
            display: flex;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .player-info {
            text-align: center;
        }
        .current-player {
            font-weight: bold;
            color: #f1c40f;
        }
        .game-board {
            display: grid;
            grid-template-columns: repeat(10, 90px);
            grid-template-rows: repeat(8, 90px);
            gap: 2px;
            justify-content: center;
            margin: 20px auto;
            background: #34495e;
            padding: 10px;
            border-radius: 10px;
        }
        .tile {
            width: 90px;
            height: 90px;
            border: 2px solid #7f8c8d;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            background: #95a5a6;
            transition: all 0.2s ease;
        }
        .tile:hover {
            border-color: #f39c12;
            transform: scale(1.05);
        }
        .tile.selected {
            border: 3px solid #f1c40f;
            background: #ffe082;
            box-shadow: 0 0 10px #f1c40f;
        }
        .tile.move-target {
            background: #2ecc71 !important;
            border: 3px dashed #27ae60;
        }
        .tile.attack-target {
            background: rgba(231, 76, 60, 0.5);
            border-color: #e74c3c;
        }
        .unit {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            border: 3px solid;
            position: relative;
            color: white;
        }
        .unit.player1 {
            background: linear-gradient(135deg, #3498db, #2980b9);
            border-color: #2980b9;
        }
        .unit.player2 {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            border-color: #c0392b;
        }
        .building {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            border: 3px solid;
            border-radius: 5px;
        }
        .building.player1 {
            background: linear-gradient(135deg, #3498db, #2980b9);
            border-color: #2980b9;
            color: white;
        }
        .building.player2 {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            border-color: #c0392b;
            color: white;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        .btn {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .btn:hover {
            background: linear-gradient(135deg, #e67e22, #d35400);
            transform: translateY(-2px);
        }
        .btn:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            transform: none;
        }
        .action-panel {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }
        .unit-info {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            text-align: center;
        }
        .health-bar {
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #e74c3c;
            border-radius: 2px;
        }
        .health-fill {
            height: 100%;
            background: #2ecc71;
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        .status-message {
            text-align: center;
            font-size: 18px;
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid #2ecc71;
        }
        .top-left-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
        }
        .tile.water {
            background: linear-gradient(135deg, #00bfff 70%, #0077be 100%);
            border-color: #0077be;
        }
        .tile.forest {
            background: linear-gradient(135deg, #27ae60 70%, #145a32 100%);
            border-color: #145a32;
        }
        .tile.plain {
            background: #95a5a6;
            border-color: #7f8c8d;
        }
        .tile.fog {
            background: repeating-linear-gradient(135deg, #222 60%, #444 100%);
            opacity: 0.7;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="top-left-controls">
        <button class="btn" id="newGameBtn">New Game (PvP)</button>
        <button class="btn" id="aiGameBtn">New Game vs AI</button>
        <button class="btn" id="aiVsAiBtn">AI vs AI (No Fog)</button>
    </div>
    <div class="container">
        <h1>TileCraft</h1>
        <!-- Terrain legend -->
        <div style="text-align:center;margin-bottom:10px;">
            <span style="display:inline-block;width:30px;height:30px;background:#00bfff;border-radius:5px;border:2px solid #0077be;margin-right:8px;"></span> Water
            <span style="display:inline-block;width:30px;height:30px;background:#27ae60;border-radius:5px;border:2px solid #145a32;margin:0 8px;"></span> Forest
            <span style="display:inline-block;width:30px;height:30px;background:#95a5a6;border-radius:5px;border:2px solid #7f8c8d;margin-left:8px;"></span> Plain
        </div>
        <!-- Add turn counter and resource node counter -->
        <div class="game-info">
            <div class="player-info">
                <div>Player 1 (Blue)</div>
                <div>Resources: <span id="p1-resources">100</span></div>
                <div>Units: <span id="p1-units">1</span></div>
                <div>Nodes: <span id="p1-nodes">0</span></div>
            </div>
            <div class="player-info">
                <div id="current-turn" class="current-player">Player 1's Turn</div>
                <div id="game-status">Select a unit to move</div>
                <div>Turn: <span id="turn-counter">1</span></div>
            </div>
            <div class="player-info">
                <div>Player 2 (Red)</div>
                <div>Resources: <span id="p2-resources">100</span></div>
                <div>Units: <span id="p2-units">1</span></div>
                <div>Nodes: <span id="p2-nodes">0</span></div>
            </div>
        </div>

        <div class="status-message" style="background:#f39c12;color:#222;">
            <b>How to Play:</b> Click your unit to select it. Green = move, Red = attack. Use the buttons or click a highlighted tile. End your turn when done!
        </div>

        <div class="game-board" id="gameBoard">
            <!-- Tiles will be generated here -->
        </div>

        <div class="action-panel">
            <button class="btn" id="attackBtn" disabled>Attack</button>
            <button class="btn" id="endTurnBtn">End Turn</button>
        </div>

        <div class="controls">
            <button class="btn" id="resetBtn">Reset</button>
            <span id="recruitP1Container">
                <button class="btn" id="recruitP1Btn">Recruit Blue Republic Gunner (50)</button>
            </span>
            <span id="recruitP2Container">
                <button class="btn" id="recruitP2Btn">Recruit Red War (50)</button>
            </span>
        </div>

        <div class="unit-info" id="unitInfo" style="display: none;">
            <h3 id="unitName">Unit Name</h3>
            <p id="unitDescription">Unit description and abilities</p>
            <div>Health: <span id="unitHealth">100</span>/100</div>
            <div>Movement: <span id="unitMovement">3</span></div>
            <div>Attack: <span id="unitAttack">25</span></div>
            <div>Range: <span id="unitRange">1</span></div>
        </div>

        <div class="status-message" id="statusMessage">
            Welcome to TileCraft! Player 1 starts first.
        </div>
    </div>

    <script>
class TileCraftGame {
    constructor() {
        this.board = [];
        this.players = [];
        this.currentPlayer = 0;
        this.selectedUnit = null;
        this.selectedTile = null;
        this.gameState = 'playing'; // 'playing', 'gameOver'
        this.moveTargets = [];
        this.attackTargets = [];
        this.isAIGame = false; // Add this property
        this.aiThinking = false; // Add this property
        this.isAIVsAI = false; // Add this property
        
        this.turnCount = 1;
        
        this.initializeGame();
        this.setupEventListeners();
    }

    initializeGame() {
        this.createBoard();
        this.createPlayers();
        this.placeInitialUnits();
        this.turnCount = 1;
        this.updateFog(); // Ensure fog is set before first render
        this.render();
        this.updateUI();
    }

    // Update fog of war for current player (called at start, after turn, and after AI turn)
    updateFog() {
        // Always remove fog in AI vs AI mode
        if (this.isAIVsAI) {
            this.fog = Array.from({length:8}, () => Array(10).fill(1));
            return;
        }

        // Normal fog calculation for other modes
        this.fog = Array.from({length:8}, () => Array(10).fill(0));
        const player = this.players[this.currentPlayer];
        // Units provide vision based on their stats
        for (const unit of player.units) {
            // Vision radius: movement + range + 1 (minimum 2)
            const vision = Math.max(2, unit.movement + (unit.range || 1));
            for (let dr = -vision; dr <= vision; dr++) {
                for (let dc = -vision; dc <= vision; dc++) {
                    const nr = unit.row + dr, nc = unit.col + dc;
                    if (this.isValidPosition(nr, nc) && Math.abs(dr) + Math.abs(dc) <= vision) {
                        this.fog[nr][nc] = 1;
                    }
                }
            }
        }
        // Buildings provide vision radius 2
        for (const building of player.buildings) {
            for (let dr = -2; dr <= 2; dr++) {
                for (let dc = -2; dc <= 2; dc++) {
                    const nr = building.row + dr, nc = building.col + dc;
                    if (this.isValidPosition(nr, nc) && Math.abs(dr) + Math.abs(dc) <= 2) {
                        this.fog[nr][nc] = 1;
                    }
                }
            }
        }
        // --- Always reveal both HQs/main bases for both players ---
        for (const p of this.players) {
            const base = p.buildings.find(b => b.type === 'base');
            if (base) {
                this.fog[base.row][base.col] = 1;
            }
        }
        // Mark explored tiles (previously seen)
        if (!player.visionTiles) player.visionTiles = new Set();
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 10; col++) {
                const key = `${row},${col}`;
                if (this.fog[row][col] === 1) {
                    player.visionTiles.add(key);
                } else if (player.visionTiles.has(key)) {
                    this.fog[row][col] = 2; // explored but not currently visible
                }
            }
        }
    }

    createBoard() {
        const boardElement = document.getElementById('gameBoard');
        boardElement.innerHTML = '';
        for (let row = 0; row < 8; row++) {
            this.board[row] = [];
            for (let col = 0; col < 10; col++) {
                // Assign terrain type randomly (weighted: more plains)
                let terrain;
                const rand = Math.random();
                if (rand < 0.15) terrain = 'water';
                else if (rand < 0.35) terrain = 'forest';
                else terrain = 'plain';

                const tile = {
                    row: row,
                    col: col,
                    unit: null,
                    building: null,
                    element: null,
                    terrain: terrain
                };

                const tileElement = document.createElement('div');
                tileElement.className = `tile ${terrain}`;
                tileElement.dataset.row = row;
                tileElement.dataset.col = col;
                tileElement.title = terrain.charAt(0).toUpperCase() + terrain.slice(1); // Tooltip
                tileElement.addEventListener('click', (e) => this.handleTileClick(row, col));

                tile.element = tileElement;
                this.board[row][col] = tile;
                boardElement.appendChild(tileElement);
            }
        }
    }

    createPlayers() {
        this.players = [
            {
                id: 0,
                name: 'Player 1',
                color: 'player1',
                resources: 100,
                units: [],
                buildings: [],
                recruitedThisTurn: false,
                visionTiles: new Set() // use Set for fast lookup
            },
            {
                id: 1,
                name: 'Player 2',
                color: 'player2',
                resources: 100,
                units: [],
                buildings: [],
                recruitedThisTurn: false,
                visionTiles: new Set()
            }
        ];
    }

    placeInitialUnits() {
        // Improved spawn logic: prefer closest non-water, fallback to random non-water if needed
        function findValidSpawn(board, row, col) {
            if (board[row][col].terrain !== 'water') return {row, col};
            // Spiral search for nearest non-water tile
            for (let radius = 1; radius < Math.max(board.length, board[0].length); radius++) {
                for (let dr = -radius; dr <= radius; dr++) {
                    for (let dc = -radius; dc <= radius; dc++) {
                        let nr = row + dr, nc = col + dc;
                        if (nr >= 0 && nr < 8 && nc >= 0 && nc < 10 && board[nr][nc].terrain !== 'water') {
                            return {row: nr, col: nc};
                        }
                    }
                }
            }
            // fallback: random non-water tile
            let candidates = [];
            for (let r = 0; r < 8; r++) for (let c = 0; c < 10; c++)
                if (board[r][c].terrain !== 'water') candidates.push({row: r, col: c});
            return candidates[Math.floor(Math.random() * candidates.length)];
        }

        let p1base = findValidSpawn(this.board, 0, 0);
        this.createBuilding('base', 0, p1base.row, p1base.col);
        let p1unit = findValidSpawn(this.board, 0, 1);
        this.createUnit('BRG', 0, p1unit.row, p1unit.col);

        let p2base = findValidSpawn(this.board, 7, 9);
        this.createBuilding('base', 1, p2base.row, p2base.col);
        let p2unit = findValidSpawn(this.board, 7, 8);
        this.createUnit('UFS RW', 1, p2unit.row, p2unit.col);

        // Place resource nodes (avoid water, avoid stacking)
        let resources = [
            {row: 3, col: 4},
            {row: 4, col: 5},
            {row: 2, col: 7},
            {row: 5, col: 2}
        ];
        let used = {};
        for (let pos of resources) {
            let spawn = findValidSpawn(this.board, pos.row, pos.col);
            let key = `${spawn.row},${spawn.col}`;
            if (!used[key]) {
                this.createBuilding('resource', null, spawn.row, spawn.col);
                used[key] = true;
            }
        }
    }

    createUnit(type, playerId, row, col) {
        // Prevent spawning on water
        if (this.board[row][col].terrain === 'water') return null;
        const unitTypes = {
            BRG: {
                name: 'Blue Republic Gunner',
                health: 100,
                maxHealth: 100,
                attack: 20,
                movement: 3,
                range: 2,
                symbol: 'BRG',
                description: 'These are gunners they can ambush and attack twice!',
                canDoubleAttack: true,
                maxAttacksPerTurn: 2,
                attacksThisTurn: 0,
                canAmbush: true
            },
            'UFS RW': {
                name: 'Red War',
                health: 80,
                maxHealth: 80,
                attack: 30,
                movement: 3,
                range: 2,
                symbol: 'RedW',
                description: 'Fast unit that can move through enemies',
                canDoubleAttack: false,
                maxAttacksPerTurn: 1,
                attacksThisTurn: 0,
                canAmbush: false
            }
        };

        const unit = {
            ...unitTypes[type],
            type: type,
            player: playerId,
            row: row,
            col: col,
            moved: false,
            acted: false,
            stunned: false // <-- add this
        };

        this.board[row][col].unit = unit;
        this.players[playerId].units.push(unit);
        return unit;
    }

    createBuilding(type, playerId, row, col) {
        // Prevent spawning on water
        if (this.board[row][col].terrain === 'water') return null;
        const buildingTypes = {
            base: {
                name: 'Command Base',
                health: 200,
                symbol: '🏰',
                description: 'Main base - generate resources',
                captureProgress: 0, // Add this
                capturingPlayer: null // Add this
            },
            resource: {
                name: 'Resource Node',
                health: 100,
                symbol: '💎',
                description: 'Neutral building - capture for resources',
                captureProgress: 0,
                capturingPlayer: null
            }
        };

        const building = {
            ...buildingTypes[type],
            type: type,
            player: playerId,
            row: row,
            col: col
        };

        // For base and resource nodes, initialize capture properties
        if (type === 'base' || type === 'resource') {
            building.captureProgress = 0;
            building.capturingPlayer = null;
        }

        this.board[row][col].building = building;
        if (playerId !== null) {
            this.players[playerId].buildings.push(building);
        }
        return building;
    }

    handleTileClick(row, col) {
        // Prevent interaction with fogged tiles (only allow on visible, not explored)
        if (this.fog[row][col] !== 1) return;
        if (this.gameState !== 'playing') return;
        const tile = this.board[row][col];

        // Deployment mode
        if (this.deployMode) {
            if (this.deployTiles.some(t => t.row === row && t.col === col)) {
                this.createUnit(this.pendingDeployType, this.pendingDeployPlayer, row, col);
                this.players[this.pendingDeployPlayer].resources -= 50;
                this.players[this.pendingDeployPlayer].recruitedThisTurn = true;
                this.deployMode = false;
                this.deployTiles = [];
                this.pendingDeployType = null;
                this.pendingDeployPlayer = null;
                this.render();
                this.updateUI();
                this.setStatus(`${this.players[this.currentPlayer].name} deployed a unit!`);
            }
            // Clear deploy highlights if clicked elsewhere
            return;
        }

        // If clicking on a move target
        if (this.moveTargets.some(t => t.row === row && t.col === col)) {
            this.moveUnit(this.selectedUnit, row, col);
            return;
        }

        // If clicking on an attack target
        if (this.attackTargets.some(t => t.row === row && t.col === col)) {
            this.attackUnit(this.selectedUnit, tile.unit);
            return;
        }

        // Clear previous selection
        this.clearSelection();

        // Select unit if it belongs to current player
        if (tile.unit && tile.unit.player === this.currentPlayer) {
            this.selectUnit(tile.unit, row, col);
        } else if (tile.unit && tile.unit.player !== this.currentPlayer) {
            this.setStatus("You can't select the other player's unit!");
        } else {
            this.setStatus("Click your unit to select it.");
        }
    }

    selectUnit(unit, row, col) {
        if (unit.stunned) {
            this.setStatus(`${unit.name} is stunned and cannot act this turn!`);
            return;
        }
        this.selectedUnit = unit;
        this.selectedTile = { row, col };
        
        // Highlight selected tile
        this.board[row][col].element.classList.add('selected');
        
        // Show possible moves and attacks
        this.showPossibleActions(unit);
        this.updateActionButtons();
        this.showUnitInfo(unit);
    }

    showPossibleActions(unit) {
        if (!unit.moved) {
            this.moveTargets = this.getPossibleMoves(unit);
            this.moveTargets.forEach(target => {
                this.board[target.row][target.col].element.classList.add('move-target');
            });
        }

        // FIX THIS CONDITION:
        if (!unit.acted || (unit.maxAttacksPerTurn > 1 && unit.attacksThisTurn < unit.maxAttacksPerTurn)) {
            this.attackTargets = this.getPossibleAttacks(unit);
            this.attackTargets.forEach(target => {
                this.board[target.row][target.col].element.classList.add('attack-target');
            });
        }
    }

    getPossibleMoves(unit) {
        const moves = [];
        const maxMove = unit.movement;
        const startRow = unit.row;
        const startCol = unit.col;

        // BFS for movement cost (forest costs 2, water impassable)
        const visited = Array.from({length:8},()=>Array(10).fill(false));
        const queue = [{row: startRow, col: startCol, cost: 0}];

        while (queue.length) {
            const {row, col, cost} = queue.shift();
            for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (!this.isValidPosition(newRow, newCol)) continue;
                if (visited[newRow][newCol]) continue;
                if (newRow === startRow && newCol === startCol) continue;

                const tile = this.board[newRow][newCol];
                // Water is impassable
                if (tile.terrain === 'water') continue;
                // Can't move onto enemy buildings
                if (tile.building && tile.building.player !== unit.player && tile.building.player !== null) continue;
                // Can't move onto units
                if (tile.unit) continue;

                // Forest costs 2 movement, plain costs 1
                const moveCost = tile.terrain === 'forest' ? 2 : 1;
                const totalCost = cost + moveCost;
                if (totalCost > maxMove) continue;

                moves.push({row: newRow, col: newCol});
                visited[newRow][newCol] = true;
                queue.push({row: newRow, col: newCol, cost: totalCost});
            }
        }
        return moves;
    }

    getPossibleAttacks(unit) {
        const attacks = [];
        const maxRange = unit.range || 1;
        const startRow = unit.row;
        const startCol = unit.col;

        for (let dr = -maxRange; dr <= maxRange; dr++) {
            for (let dc = -maxRange; dc <= maxRange; dc++) {
                if (Math.abs(dr) + Math.abs(dc) === 0) continue; // skip self
                if (Math.abs(dr) + Math.abs(dc) > maxRange) continue; // only within range

                const newRow = startRow + dr;
                const newCol = startCol + dc;
                if (!this.isValidPosition(newRow, newCol)) continue;

                const tile = this.board[newRow][newCol];
                if (tile.unit && tile.unit.player !== unit.player) {
                    attacks.push({ row: newRow, col: newCol });
                }
            }
        }
        return attacks;
    }

    moveUnit(unit, newRow, newCol) {
        // Clear old position
        this.board[unit.row][unit.col].unit = null;
        
        // Set new position
        unit.row = newRow;
        unit.col = newCol;
        unit.moved = true;
        this.board[newRow][newCol].unit = unit;
        
        this.clearSelection();
        this.updateFog(); // Update fog after moving
        this.render();
        this.updateUI();
        this.setStatus(`${unit.name} moved to (${newRow}, ${newCol})`);
    }

    attackUnit(attacker, defender) {
        const damage = attacker.attack;
        defender.health -= damage;

        // Passive ambush: if attacker can ambush, stun and deal extra damage
        if (attacker.canAmbush) {
            const ambushDamage = 15; // or any value you want
            defender.health -= ambushDamage;
            defender.stunned = true;
            this.setStatus(`${attacker.name} attacks and ambushes ${defender.name} for ${damage + ambushDamage} damage and stuns them!`);
        } else {
            this.setStatus(`${attacker.name} attacks ${defender.name} for ${damage} damage!`);
        }

        attacker.attacksThisTurn = (attacker.attacksThisTurn || 0) + 1;

        // Mark as acted if reached max attacks per turn
        if (attacker.attacksThisTurn >= (attacker.maxAttacksPerTurn || 1)) {
            attacker.acted = true;
        }

        if (defender.health <= 0) {
            this.destroyUnit(defender);
            this.setStatus(`${defender.name} has been destroyed!`);
        }

        this.clearSelection();
        this.updateFog(); // Update fog after attack (in case vision changes)
        this.render();
        this.updateUI();
        this.checkGameOver();
    }

    ambushUnit(attacker, defender) {
        if (!attacker.canAmbush) {
            this.setStatus(`${attacker.name} cannot ambush!`);
            return;
        }
        const ambushDamage = 15; // or any value you want
        defender.health -= ambushDamage;
        defender.stunned = true; // Stun the defender

        this.setStatus(`${attacker.name} ambushed ${defender.name} for ${ambushDamage} damage and stunned them!`);

        if (defender.health <= 0) {
            this.destroyUnit(defender);
            this.setStatus(`${defender.name} has been destroyed!`);
        }

        attacker.acted = true;
        this.clearSelection();
        this.render();
        this.updateUI();
    }

    destroyUnit(unit) {
        // Remove from board
        this.board[unit.row][unit.col].unit = null;
        
        // Remove from player's unit list
        const playerUnits = this.players[unit.player].units;
        const index = playerUnits.indexOf(unit);
        if (index > -1) {
            playerUnits.splice(index, 1);
        }
    }

    clearSelection() {
        this.selectedUnit = null;
        this.selectedTile = null;
        
        // Clear all highlights
        document.querySelectorAll('.tile').forEach(tile => {
            tile.classList.remove('selected', 'move-target', 'attack-target');
        });
        
        this.moveTargets = [];
        this.attackTargets = [];
        this.updateActionButtons();
        this.hideUnitInfo();
    }

    endTurn() {
        // Resource generation and unit reset
        this.players[this.currentPlayer].resources += 10;
        for (const building of this.players[this.currentPlayer].buildings) {
            if (building.type === 'resource') {
                this.players[this.currentPlayer].resources += 10;
            }
        }
        this.players[this.currentPlayer].units.forEach(unit => {
            unit.moved = false;
            unit.acted = false;
            unit.attacksThisTurn = 0;
            unit.stunned = false;
        });

        // Switch players
        this.currentPlayer = (this.currentPlayer + 1) % 2;
        this.players[this.currentPlayer].recruitedThisTurn = false;
        this.turnCount++;
        this.clearSelection();
        this.updateFog();
        this.render();
        this.updateUI();

        // --- AI should act IMMEDIATELY at the start of its turn ---
        if (this.gameState === 'playing') {
            if (this.isAIVsAI) {
                setTimeout(() => this.runAIVsAIBattle(), 500);
            } else if (this.isAIGame && this.currentPlayer === 1) {
                setTimeout(() => this.makeAIMove(), 500);
            }
        }
    }

    runAIVsAIBattle() {
        if (!this.isAIVsAI || this.gameState !== 'playing') return;
        this.setStatus(`${this.players[this.currentPlayer].name} is thinking...`);
        setTimeout(() => {
            this.executeAITurn();
            // Only call endTurn if the game is still running
            if (this.gameState === 'playing') {
                this.endTurn();
            }
        }, 500);
    }

    makeAIMove() {
        if (!this.isAIGame || this.currentPlayer !== 1 || this.gameState !== 'playing') return;
        this.setStatus('AI is thinking...');
        this.aiThinking = true;
        setTimeout(() => {
            this.executeAITurn();
            this.aiThinking = false;
            if (this.gameState === 'playing') {
                this.endTurn();
            }
        }, 500);
    }

    // --- Improved AI logic ---
    executeAITurn() {
        const currentPlayer = this.players[this.currentPlayer];
        const enemyPlayer = this.players[this.currentPlayer === 0 ? 1 : 0];

        // Defensive: If HQ is threatened, move units to block/counter
        const aiBase = currentPlayer.buildings.find(b => b.type === 'base');
        let baseThreat = false;
        if (aiBase) {
            for (const enemyUnit of enemyPlayer.units) {
                if (Math.abs(enemyUnit.row - aiBase.row) + Math.abs(enemyUnit.col - aiBase.col) <= 2) {
                    baseThreat = true;
                    break;
                }
            }
        }

        // 1. Attack: Prioritize attacking units that threaten HQ or are weak
        for (const unit of currentPlayer.units) {
            if (unit.acted && !(unit.maxAttacksPerTurn > 1 && unit.attacksThisTurn < unit.maxAttacksPerTurn)) continue;
            const attackTargets = this.getPossibleAttacks(unit);
            if (attackTargets.length > 0) {
                // Prefer attacking units near AI base, then lowest health
                let bestTarget = null;
                let bestScore = -Infinity;
                for (const target of attackTargets) {
                    const enemyUnit = this.board[target.row][target.col].unit;
                    let score = 0;
                    if (aiBase) {
                        // Threat to base gets high score
                        score -= Math.abs(enemyUnit.row - aiBase.row) + Math.abs(enemyUnit.col - aiBase.col) <= 2 ? 100 : 0;
                    }
                    score -= enemyUnit.health; // Prefer low health
                    score += enemyUnit.attack; // Prefer high attack units
                    if (score > bestScore) {
                        bestScore = score;
                        bestTarget = enemyUnit;
                    }
                }
                if (bestTarget) {
                    this.attackUnit(unit, bestTarget);
                    return; // Only one attack per AI turn for realism
                }
            }
        }

        // 2. Capture: Move units onto neutral or enemy resource nodes if possible
        for (const unit of currentPlayer.units) {
            if (unit.moved) continue;
            const moveTargets = this.getPossibleMoves(unit);
            let bestMove = null;
            for (const move of moveTargets) {
                const tile = this.board[move.row][move.col];
                if (tile.building && tile.building.type === 'resource' && tile.building.player !== 1) {
                    bestMove = move;
                    break;
                }
                // Try to move onto enemy HQ if possible
                if (tile.building && tile.building.type === 'base' && tile.building.player !== 1) {
                    bestMove = move;
                    break;
                }
            }
            if (bestMove) {
                this.moveUnit(unit, bestMove.row, bestMove.col);
                return;
            }
        }

        // 3. Recruit: If resources and space, recruit near base if not threatened
        if (currentPlayer.resources >= 50 && !currentPlayer.recruitedThisTurn && aiBase) {
            const directions = [[-1,0],[1,0],[0,-1],[0,1]];
            let validTiles = [];
            for (const [dr, dc] of directions) {
                const row = aiBase.row + dr;
                const col = aiBase.col + dc;
                if (this.isValidPosition(row, col) && !this.board[row][col].unit && !this.board[row][col].building) {
                    validTiles.push({row, col});
                }
            }
            if (validTiles.length > 0) {
                // Prefer tile closest to enemy units
                let bestTile = validTiles[0];
                let minDist = Infinity;
                for (const tile of validTiles) {
                    let dist = Infinity;
                    for (const enemyUnit of enemyPlayer.units) {
                        dist = Math.min(dist, Math.abs(tile.row - enemyUnit.row) + Math.abs(tile.col - enemyUnit.col));
                    }
                    if (dist < minDist) {
                        minDist = dist;
                        bestTile = tile;
                    }
                }
                this.createUnit('UFS RW', 1, bestTile.row, bestTile.col);
                currentPlayer.resources -= 50;
                currentPlayer.recruitedThisTurn = true;
                this.setStatus("AI recruited a unit.");
                this.render();
                this.updateUI();
                return;
            }
        }

        // 4. Move: Advance units toward closest enemy or resource node, avoid water
        for (const unit of currentPlayer.units) {
            if (unit.moved) continue;
            const moveTargets = this.getPossibleMoves(unit);
            if (moveTargets.length > 0) {
                // Prefer moving toward closest enemy unit
                let bestMove = null;
                let bestDist = Infinity;
                for (const move of moveTargets) {
                    for (const enemyUnit of enemyPlayer.units) {
                        const dist = Math.abs(move.row - enemyUnit.row) + Math.abs(move.col - enemyUnit.col);
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestMove = move;
                        }
                    }
                }
                // If no enemy units, move toward nearest resource node
                if (!bestMove) {
                    for (const move of moveTargets) {
                        for (let row = 0; row < 8; row++) {
                            for (let col = 0; col < 10; col++) {
                                const tile = this.board[row][col];
                                if (tile.building && tile.building.type === 'resource' && tile.building.player !== 1) {
                                    const dist = Math.abs(move.row - row) + Math.abs(move.col - col);
                                    if (dist < bestDist) {
                                        bestDist = dist;
                                        bestMove = move;
                                    }
                                }
                            }
                        }
                    }
                }
                if (bestMove) {
                    this.moveUnit(unit, bestMove.row, bestMove.col);
                    return;
                }
            }
        }

        // If nothing to do, just end turn
    }

    checkGameOver() {
        for (let i = 0; i < this.players.length; i++) {
            if (this.players[i].units.length === 0) {
                this.gameState = 'gameOver';
                const winner = this.players[1 - i];
                this.setStatus(`🎉 ${winner.name} wins! 🎉`);
                return true;
            }
        }
        return false;
    }

    isValidPosition(row, col) {
        return row >= 0 && row < 8 && col >= 0 && col < 10;
    }

    render() {
        // Ensure AI vs AI mode has no fog before rendering
        if (this.isAIVsAI) {
            this.fog = Array.from({length:8}, () => Array(10).fill(1));
        }

        // Clear all tiles
        document.querySelectorAll('.tile').forEach(tile => {
            tile.innerHTML = '';
            tile.className = 'tile';
        });

        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 10; col++) {
                const tile = this.board[row][col];
                // Fog logic
                if (this.fog[row][col] === 0) {
                    tile.element.className = `tile fog`;
                    tile.element.innerHTML = '';
                    continue;
                }
                if (this.fog[row][col] === 2) {
                    tile.element.className = `tile fog`;
                    tile.element.style.opacity = "0.4";
                    tile.element.innerHTML = '';
                    tile.element.textContent = tile.terrain.charAt(0).toUpperCase();
                    continue;
                }
                tile.element.className = `tile ${tile.terrain}`;
                tile.element.style.opacity = "";
                tile.element.innerHTML = '';
                
                if (tile.building) {
                    const buildingElement = document.createElement('div');
                    buildingElement.className = `building ${tile.building.player !== null ? this.players[tile.building.player].color : 'neutral'}`;
                    buildingElement.textContent = tile.building.symbol;
                    // Show capture progress bar if being captured
                    if ((tile.building.type === 'base' || tile.building.type === 'resource') && tile.building.captureProgress > 0) {
                        const progressBar = document.createElement('div');
                        progressBar.style.position = 'absolute';
                        progressBar.style.bottom = '2px';
                        progressBar.style.left = '5px';
                        progressBar.style.width = '50px';
                        progressBar.style.height = '6px';
                        progressBar.style.background = '#333';
                        progressBar.style.borderRadius = '3px';
                        const fill = document.createElement('div');
                        fill.style.height = '100%';
                        fill.style.width = `${tile.building.captureProgress * 50 / 2}px`; // 2 turns to capture
                        fill.style.background = '#f39c12';
                        fill.style.borderRadius = '3px';
                        progressBar.appendChild(fill);
                        buildingElement.appendChild(progressBar);
                    }
                    tile.element.appendChild(buildingElement);
                }
                
                if (tile.unit) {
                    const unitElement = document.createElement('div');
                    unitElement.className = `unit ${this.players[tile.unit.player].color}`;
                    unitElement.textContent = tile.unit.symbol;
                    
                    // Add health bar
                    const healthBar = document.createElement('div');
                    healthBar.className = 'health-bar';
                    const healthFill = document.createElement('div');
                    healthFill.className = 'health-fill';
                    healthFill.style.width = `${(tile.unit.health / tile.unit.maxHealth) * 100}%`;
                    healthBar.appendChild(healthFill);
                    unitElement.appendChild(healthBar);
                    
                    tile.element.appendChild(unitElement);
                }
            }
        }
    }

    updateUI() {
        document.getElementById('current-turn').textContent = `${this.players[this.currentPlayer].name}'s Turn`;
        document.getElementById('p1-resources').textContent = this.players[0].resources;
        document.getElementById('p2-resources').textContent = this.players[1].resources;
        document.getElementById('p1-units').textContent = this.players[0].units.length;
        document.getElementById('p2-units').textContent = this.players[1].units.length;
        document.getElementById('turn-counter').textContent = this.turnCount;
        // Show resource node count
        document.getElementById('p1-nodes').textContent = this.players[0].buildings.filter(b => b.type === 'resource').length;
        document.getElementById('p2-nodes').textContent = this.players[1].buildings.filter(b => b.type === 'resource').length;

        // Show only the current player's recruit button
        document.getElementById('recruitP1Container').style.display = this.currentPlayer === 0 ? 'inline' : 'none';
        document.getElementById('recruitP2Container').style.display = this.currentPlayer === 1 ? 'inline' : 'none';

        // Disable recruit button if on cooldown
        if (this.currentPlayer === 0) {
            document.getElementById('recruitP1Btn').disabled = this.players[0].recruitedThisTurn;
            document.getElementById('recruitP1Btn').textContent = this.players[0].recruitedThisTurn
                ? 'Recruit Blue Republic Gunner (Cooldown)'
                : 'Recruit Blue Republic Gunner (50)';
        } else {
            document.getElementById('recruitP2Btn').disabled = this.players[1].recruitedThisTurn;
            document.getElementById('recruitP2Btn').textContent = this.players[1].recruitedThisTurn
                ? 'Recruit Red War (Cooldown)'
                : 'Recruit Red War (50)';
        }
    }

    updateActionButtons() {
        const attackBtn = document.getElementById('attackBtn');
        const hasSelection = this.selectedUnit !== null;
        const canMove = hasSelection && !this.selectedUnit.moved && this.moveTargets.length > 0;
        const canAttack = hasSelection &&
            (!this.selectedUnit.acted ||
            (this.selectedUnit.maxAttacksPerTurn > 1 && this.selectedUnit.attacksThisTurn < this.selectedUnit.maxAttacksPerTurn))
            && this.attackTargets.length > 0;
        attackBtn.disabled = !canAttack;
        // ...removed ambushBtn logic comment...
    }

    showUnitInfo(unit) {
        // Only show info if tile is visible
        if (this.fog[unit.row][unit.col] !== 1) return;

        const unitInfo = document.getElementById('unitInfo');
        // Determine which side to display info based on HQ position
        let base = this.players[unit.player].buildings.find(b => b.type === 'base');
        let side = 'left';
        if (base && base.col > 4) side = 'right';

        // Position the info panel accordingly
        unitInfo.style.position = 'absolute';
        unitInfo.style.top = '120px';
        unitInfo.style[side] = '40px';
        unitInfo.style[side === 'left' ? 'right' : 'left'] = 'auto';

        // Refined stat system
        let stats = [
            { label: 'Health', value: `${unit.health}/${unit.maxHealth}` },
            { label: 'Movement', value: unit.movement },
            { label: 'Attack', value: unit.attack },
            { label: 'Range', value: unit.range || 1 },
            { label: 'Special', value: unit.canDoubleAttack ? 'Double Attack' : unit.canAmbush ? 'Ambush' : 'None' }
        ];

        unitInfo.innerHTML = `
            <h3>${unit.name}</h3>
            <p style="font-size:14px;">${unit.description}</p>
            <table style="margin:0 auto;text-align:left;">
                ${stats.map(s => `<tr><td><b>${s.label}:</b></td><td>${s.value}</td></tr>`).join('')}
            </table>
            <div style="margin-top:8px;">
                Terrain: ${this.board[unit.row][unit.col].terrain.charAt(0).toUpperCase() + this.board[unit.row][unit.col].terrain.slice(1)}
                ${this.board[unit.row][unit.col].terrain === 'forest' ? '<span style="color:#2ecc71;">(+5 Defense)</span>' : ''}
            </div>
        `;
        unitInfo.style.display = 'block';
    }

    hideUnitInfo() {
        const unitInfo = document.getElementById('unitInfo');
        unitInfo.style.display = 'none';
        unitInfo.style.position = '';
        unitInfo.style.left = '';
        unitInfo.style.right = '';
        unitInfo.style.top = '';
    }

    // Add deployment selection logic
    deployMode = false;
    deployTiles = [];
    pendingDeployType = null;
    pendingDeployPlayer = null;

    showDeployTiles(playerId, unitType) {
        // Find base
        const base = this.players[playerId].buildings.find(b => b.type === 'base');
        if (!base) return;
        this.deployTiles = [];
        // Adjacent tiles to base
        const directions = [[-1,0],[1,0],[0,-1],[0,1]];
        for (const [dr, dc] of directions) {
            const row = base.row + dr;
            const col = base.col + dc;
            if (this.isValidPosition(row, col) && !this.board[row][col].unit && !this.board[row][col].building) {
                this.deployTiles.push({row, col});
                this.board[row][col].element.classList.add('move-target');
            }
        }
        this.deployMode = true;
        this.pendingDeployType = unitType;
        this.pendingDeployPlayer = playerId;
        this.setStatus("Select a tile next to your HQ to deploy your unit.");
    }

    handleTileClick(row, col) {
        // Prevent interaction with fogged tiles (only allow on visible, not explored)
        if (this.fog[row][col] !== 1) return;

        if (this.gameState !== 'playing') return;

        const tile = this.board[row][col];

        // Deployment mode
        if (this.deployMode) {
            if (this.deployTiles.some(t => t.row === row && t.col === col)) {
                this.createUnit(this.pendingDeployType, this.pendingDeployPlayer, row, col);
                this.players[this.pendingDeployPlayer].resources -= 50;
                this.players[this.pendingDeployPlayer].recruitedThisTurn = true;
                this.deployMode = false;
                this.deployTiles = [];
                this.pendingDeployType = null;
                this.pendingDeployPlayer = null;
                this.render();
                this.updateUI();
                this.setStatus(`${this.players[this.currentPlayer].name} deployed a unit!`);
            }
            // Clear deploy highlights if clicked elsewhere
            return;
        }

        // If clicking on a move target
        if (this.moveTargets.some(t => t.row === row && t.col === col)) {
            this.moveUnit(this.selectedUnit, row, col);
            return;
        }

        // If clicking on an attack target
        if (this.attackTargets.some(t => t.row === row && t.col === col)) {
            this.attackUnit(this.selectedUnit, tile.unit);
            return;
        }

        // Clear previous selection
        this.clearSelection();

        // Select unit if it belongs to current player
        if (tile.unit && tile.unit.player === this.currentPlayer) {
            this.selectUnit(tile.unit, row, col);
        } else if (tile.unit && tile.unit.player !== this.currentPlayer) {
            this.setStatus("You can't select the other player's unit!");
        } else {
            this.setStatus("Click your unit to select it.");
        }
    }

    recruitUnit(playerId) {
        // Only allow if it's this player's turn
        if (this.currentPlayer !== playerId || this.gameState !== 'playing') {
            this.setStatus("It's not your turn!");
            return;
        }
        // Check cooldown
        if (this.players[playerId].recruitedThisTurn) {
            this.setStatus("You can only recruit once per turn!");
            return;
        }
        // Set cost and type
        const unitType = playerId === 0 ? 'BRG' : 'UFS RW';
        const cost = 50;
        if (this.players[playerId].resources < cost) {
            this.setStatus("Not enough resources!");
            return;
        }
        // Find base position
        const base = this.players[playerId].buildings.find(b => b.type === 'base');
        if (!base || base.player !== playerId) {
            this.setStatus("You can't recruit from a captured HQ!");
            return;
        }
        // Show deploy tiles instead of auto-spawn
        this.showDeployTiles(playerId, unitType);
    }

    setupEventListeners() {
        document.getElementById('endTurnBtn').addEventListener('click', () => {
            if (this.gameState === 'playing' && (!this.isAIGame || this.currentPlayer === 0)) {
                this.endTurn();
            }
        });

        document.getElementById('newGameBtn').addEventListener('click', () => {
            this.isAIGame = false;
            this.gameState = 'playing';
            this.currentPlayer = 0;
            this.createBoard();
            this.createPlayers();
            this.placeInitialUnits();
            this.updateFog(); // Ensure fog is set for current player at game start
            this.render();
            this.updateUI();
            this.setStatus('New game started! Player 1 begins.');
        });

        // Add AI game button listener
        document.getElementById('aiGameBtn').addEventListener('click', () => {
            this.startAIGame();
        });

        // Add AI vs AI game button listener
        document.getElementById('aiVsAiBtn').addEventListener('click', () => {
            this.startAIVsAIGame();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            if (confirm('Are you sure you want to reset the game?')) {
                this.isAIGame = false;
                this.gameState = 'playing';
                this.currentPlayer = 0;
                // Always regenerate board and terrain
                this.createBoard();
                this.createPlayers();
                this.placeInitialUnits();
                this.render();
                this.updateUI();
                this.setStatus('Game reset! Player 1 begins.');
            }
        });

        document.getElementById('attackBtn').addEventListener('click', () => {
            if (this.selectedUnit && this.attackTargets.length > 0) {
                // Attack the first available attack target
                const target = this.attackTargets[0];
                const tile = this.board[target.row][target.col];
                this.attackUnit(this.selectedUnit, tile.unit);
            }
        });

        document.getElementById('recruitP1Btn').addEventListener('click', () => {
            this.recruitUnit(0);
        });
        document.getElementById('recruitP2Btn').addEventListener('click', () => {
            this.recruitUnit(1);
        });
    }

    startAIGame() {
        // Reset game state
        this.isAIGame = true;
        this.isAIVsAI = false;
        this.gameState = 'playing';
        this.currentPlayer = 0;
        this.aiThinking = false;

        // Initialize game
        this.createBoard();
        this.createPlayers();
        this.placeInitialUnits();
        
        // Configure AI player
        this.players[1].name = 'AI';
        
        // Initialize fog and render
        this.updateFog();
        this.render();
        this.updateUI();
        this.setStatus('AI Game started! You are Player 1 (Blue), AI is Player 2 (Red).');
        
        // Trigger AI turn if AI starts first
        if (this.currentPlayer === 1) {
            setTimeout(() => this.makeAIMove(), 1000);
        }
    }

    startAIVsAIGame() {
        // Reset game state
        this.isAIGame = true;
        this.isAIVsAI = true;
        this.gameState = 'playing';
        this.currentPlayer = 0;
        this.aiThinking = false;

        // Initialize game
        this.createBoard();
        this.createPlayers();
        this.placeInitialUnits();
        
        // Configure both players as AI
        this.players[0].name = 'AI Blue';
        this.players[1].name = 'AI Red';
        
        // Disable manual controls
        document.getElementById('endTurnBtn').disabled = true;
        document.getElementById('recruitP1Btn').disabled = true;
        document.getElementById('recruitP2Btn').disabled = true;
        
        // Remove fog for spectating
        this.fog = Array.from({length:8}, () => Array(10).fill(1));
        this.render();
        this.updateUI();
        
        // Start AI battle
        this.setStatus('AI vs AI battle started! Watch the battle unfold.');
        setTimeout(() => this.runAIVsAIBattle(), 1000);
    }

    runAIVsAIBattle() {
        if (!this.isAIVsAI || this.gameState !== 'playing') return;
        this.setStatus(`${this.players[this.currentPlayer].name} is thinking...`);
        setTimeout(() => {
            this.executeAITurn();
            // Only call endTurn if the game is still running
            if (this.gameState === 'playing') {
                this.endTurn();
            }
        }, 500);
    }

    makeAIMove() {
        if (!this.isAIGame || this.currentPlayer !== 1 || this.gameState !== 'playing') return;
        this.setStatus('AI is thinking...');
        this.aiThinking = true;
        setTimeout(() => {
            this.executeAITurn();
            this.aiThinking = false;
            if (this.gameState === 'playing') {
                this.endTurn();
            }
        }, 500);
    }

    // --- Improved AI logic ---
    executeAITurn() {
        const currentPlayer = this.players[this.currentPlayer];
        const enemyPlayer = this.players[this.currentPlayer === 0 ? 1 : 0];

        // Defensive: If HQ is threatened, move units to block/counter
        const aiBase = currentPlayer.buildings.find(b => b.type === 'base');
        let baseThreat = false;
        if (aiBase) {
            for (const enemyUnit of enemyPlayer.units) {
                if (Math.abs(enemyUnit.row - aiBase.row) + Math.abs(enemyUnit.col - aiBase.col) <= 2) {
                    baseThreat = true;
                    break;
                }
            }
        }

        // 1. Attack: Prioritize attacking units that threaten HQ or are weak
        for (const unit of currentPlayer.units) {
            if (unit.acted && !(unit.maxAttacksPerTurn > 1 && unit.attacksThisTurn < unit.maxAttacksPerTurn)) continue;
            const attackTargets = this.getPossibleAttacks(unit);
            if (attackTargets.length > 0) {
                // Prefer attacking units near AI base, then lowest health
                let bestTarget = null;
                let bestScore = -Infinity;
                for (const target of attackTargets) {
                    const enemyUnit = this.board[target.row][target.col].unit;
                    let score = 0;
                    if (aiBase) {
                        // Threat to base gets high score
                        score -= Math.abs(enemyUnit.row - aiBase.row) + Math.abs(enemyUnit.col - aiBase.col) <= 2 ? 100 : 0;
                    }
                    score -= enemyUnit.health; // Prefer low health
                    score += enemyUnit.attack; // Prefer high attack units
                    if (score > bestScore) {
                        bestScore = score;
                        bestTarget = enemyUnit;
                    }
                }
                if (bestTarget) {
                    this.attackUnit(unit, bestTarget);
                    return; // Only one attack per AI turn for realism
                }
            }
        }

        // 2. Capture: Move units onto neutral or enemy resource nodes if possible
        for (const unit of currentPlayer.units) {
            if (unit.moved) continue;
            const moveTargets = this.getPossibleMoves(unit);
            let bestMove = null;
            for (const move of moveTargets) {
                const tile = this.board[move.row][move.col];
                if (tile.building && tile.building.type === 'resource' && tile.building.player !== 1) {
                    bestMove = move;
                    break;
                }
                // Try to move onto enemy HQ if possible
                if (tile.building && tile.building.type === 'base' && tile.building.player !== 1) {
                    bestMove = move;
                    break;
                }
            }
            if (bestMove) {
                this.moveUnit(unit, bestMove.row, bestMove.col);
                return;
            }
        }

        // 3. Recruit: If resources and space, recruit near base if not threatened
        if (currentPlayer.resources >= 50 && !currentPlayer.recruitedThisTurn && aiBase) {
            const directions = [[-1,0],[1,0],[0,-1],[0,1]];
            let validTiles = [];
            for (const [dr, dc] of directions) {
                const row = aiBase.row + dr;
                const col = aiBase.col + dc;
                if (this.isValidPosition(row, col) && !this.board[row][col].unit && !this.board[row][col].building) {
                    validTiles.push({row, col});
                }
            }
            if (validTiles.length > 0) {
                // Prefer tile closest to enemy units
                let bestTile = validTiles[0];
                let minDist = Infinity;
                for (const tile of validTiles) {
                    let dist = Infinity;
                    for (const enemyUnit of enemyPlayer.units) {
                        dist = Math.min(dist, Math.abs(tile.row - enemyUnit.row) + Math.abs(tile.col - enemyUnit.col));
                    }
                    if (dist < minDist) {
                        minDist = dist;
                        bestTile = tile;
                    }
                }
                this.createUnit('UFS RW', 1, bestTile.row, bestTile.col);
                currentPlayer.resources -= 50;
                currentPlayer.recruitedThisTurn = true;
                this.setStatus("AI recruited a unit.");
                this.render();
                this.updateUI();
                return;
            }
        }

        // 4. Move: Advance units toward closest enemy or resource node, avoid water
        for (const unit of currentPlayer.units) {
            if (unit.moved) continue;
            const moveTargets = this.getPossibleMoves(unit);
            if (moveTargets.length > 0) {
                // Prefer moving toward closest enemy unit
                let bestMove = null;
                let bestDist = Infinity;
                for (const move of moveTargets) {
                    for (const enemyUnit of enemyPlayer.units) {
                        const dist = Math.abs(move.row - enemyUnit.row) + Math.abs(move.col - enemyUnit.col);
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestMove = move;
                        }
                    }
                }
                // If no enemy units, move toward nearest resource node
                if (!bestMove) {
                    for (const move of moveTargets) {
                        for (let row = 0; row < 8; row++) {
                            for (let col = 0; col < 10; col++) {
                                const tile = this.board[row][col];
                                if (tile.building && tile.building.type === 'resource' && tile.building.player !== 1) {
                                    const dist = Math.abs(move.row - row) + Math.abs(move.col - col);
                                    if (dist < bestDist) {
                                        bestDist = dist;
                                        bestMove = move;
                                    }
                                }
                            }
                        }
                    }
                }
                if (bestMove) {
                    this.moveUnit(unit, bestMove.row, bestMove.col);
                    return;
                }
            }
        }

        // If nothing to do, just end turn
    }

    checkGameOver() {
        for (let i = 0; i < this.players.length; i++) {
            if (this.players[i].units.length === 0) {
                this.gameState = 'gameOver';
                const winner = this.players[1 - i];
                this.setStatus(`🎉 ${winner.name} wins! 🎉`);
                return true;
            }
        }
        return false;
    }

    isValidPosition(row, col) {
        return row >= 0 && row < 8 && col >= 0 && col < 10;
    }

    render() {
        // Ensure AI vs AI mode has no fog before rendering
        if (this.isAIVsAI) {
            this.fog = Array.from({length:8}, () => Array(10).fill(1));
        }

        // Clear all tiles
        document.querySelectorAll('.tile').forEach(tile => {
            tile.innerHTML = '';
            tile.className = 'tile';
        });

        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 10; col++) {
                const tile = this.board[row][col];
                // Fog logic
                if (this.fog[row][col] === 0) {
                    tile.element.className = `tile fog`;
                    tile.element.innerHTML = '';
                    continue;
                }
                if (this.fog[row][col] === 2) {
                    tile.element.className = `tile fog`;
                    tile.element.style.opacity = "0.4";
                    tile.element.innerHTML = '';
                    tile.element.textContent = tile.terrain.charAt(0).toUpperCase();
                    continue;
                }
                tile.element.className = `tile ${tile.terrain}`;
                tile.element.style.opacity = "";
                tile.element.innerHTML = '';
                
                if (tile.building) {
                    const buildingElement = document.createElement('div');
                    buildingElement.className = `building ${tile.building.player !== null ? this.players[tile.building.player].color : 'neutral'}`;
                    buildingElement.textContent = tile.building.symbol;
                    // Show capture progress bar if being captured
                    if ((tile.building.type === 'base' || tile.building.type === 'resource') && tile.building.captureProgress > 0) {
                        const progressBar = document.createElement('div');
                        progressBar.style.position = 'absolute';
                        progressBar.style.bottom = '2px';
                        progressBar.style.left = '5px';
                        progressBar.style.width = '50px';
                        progressBar.style.height = '6px';
                        progressBar.style.background = '#333';
                        progressBar.style.borderRadius = '3px';
                        const fill = document.createElement('div');
                        fill.style.height = '100%';
                        fill.style.width = `${tile.building.captureProgress * 50 / 2}px`; // 2 turns to capture
                        fill.style.background = '#f39c12';
                        fill.style.borderRadius = '3px';
                        progressBar.appendChild(fill);
                        buildingElement.appendChild(progressBar);
                    }
                    tile.element.appendChild(buildingElement);
                }
                
                if (tile.unit) {
                    const unitElement = document.createElement('div');
                    unitElement.className = `unit ${this.players[tile.unit.player].color}`;
                    unitElement.textContent = tile.unit.symbol;
                    
                    // Add health bar
                    const healthBar = document.createElement('div');
                    healthBar.className = 'health-bar';
                    const healthFill = document.createElement('div');
                    healthFill.className = 'health-fill';
                    healthFill.style.width = `${(tile.unit.health / tile.unit.maxHealth) * 100}%`;
                    healthBar.appendChild(healthFill);
                    unitElement.appendChild(healthBar);
                    
                    tile.element.appendChild(unitElement);
                }
            }
        }
    }

    updateUI() {
        document.getElementById('current-turn').textContent = `${this.players[this.currentPlayer].name}'s Turn`;
        document.getElementById('p1-resources').textContent = this.players[0].resources;
        document.getElementById('p2-resources').textContent = this.players[1].resources;
        document.getElementById('p1-units').textContent = this.players[0].units.length;
        document.getElementById('p2-units').textContent = this.players[1].units.length;
        document.getElementById('turn-counter').textContent = this.turnCount;
        // Show resource node count
        document.getElementById('p1-nodes').textContent = this.players[0].buildings.filter(b => b.type === 'resource').length;
        document.getElementById('p2-nodes').textContent = this.players[1].buildings.filter(b => b.type === 'resource').length;

        // Show only the current player's recruit button
        document.getElementById('recruitP1Container').style.display = this.currentPlayer === 0 ? 'inline' : 'none';
        document.getElementById('recruitP2Container').style.display = this.currentPlayer === 1 ? 'inline' : 'none';

        // Disable recruit button if on cooldown
        if (this.currentPlayer === 0) {
            document.getElementById('recruitP1Btn').disabled = this.players[0].recruitedThisTurn;
            document.getElementById('recruitP1Btn').textContent = this.players[0].recruitedThisTurn
                ? 'Recruit Blue Republic Gunner (Cooldown)'
                : 'Recruit Blue Republic Gunner (50)';
        } else {
            document.getElementById('recruitP2Btn').disabled = this.players[1].recruitedThisTurn;
            document.getElementById('recruitP2Btn').textContent = this.players[1].recruitedThisTurn
                ? 'Recruit Red War (Cooldown)'
                : 'Recruit Red War (50)';
        }
    }

    updateActionButtons() {
        const attackBtn = document.getElementById('attackBtn');
        const hasSelection = this.selectedUnit !== null;
        const canMove = hasSelection && !this.selectedUnit.moved && this.moveTargets.length > 0;
        const canAttack = hasSelection &&
            (!this.selectedUnit.acted ||
            (this.selectedUnit.maxAttacksPerTurn > 1 && this.selectedUnit.attacksThisTurn < this.selectedUnit.maxAttacksPerTurn))
            && this.attackTargets.length > 0;
        attackBtn.disabled = !canAttack;
        // ...removed ambushBtn logic comment...
    }

    showUnitInfo(unit) {
        // Only show info if tile is visible
        if (this.fog[unit.row][unit.col] !== 1) return;

        const unitInfo = document.getElementById('unitInfo');
        // Determine which side to display info based on HQ position
        let base = this.players[unit.player].buildings.find(b => b.type === 'base');
        let side = 'left';
        if (base && base.col > 4) side = 'right';

        // Position the info panel accordingly
        unitInfo.style.position = 'absolute';
        unitInfo.style.top = '120px';
        unitInfo.style[side] = '40px';
        unitInfo.style[side === 'left' ? 'right' : 'left'] = 'auto';

        // Refined stat system
        let stats = [
            { label: 'Health', value: `${unit.health}/${unit.maxHealth}` },
            { label: 'Movement', value: unit.movement },
            { label: 'Attack', value: unit.attack },
            { label: 'Range', value: unit.range || 1 },
            { label: 'Special', value: unit.canDoubleAttack ? 'Double Attack' : unit.canAmbush ? 'Ambush' : 'None' }
        ];

        unitInfo.innerHTML = `
            <h3>${unit.name}</h3>
            <p style="font-size:14px;">${unit.description}</p>
            <table style="margin:0 auto;text-align:left;">
                ${stats.map(s => `<tr><td><b>${s.label}:</b></td><td>${s.value}</td></tr>`).join('')}
            </table>
            <div style="margin-top:8px;">
                Terrain: ${this.board[unit.row][unit.col].terrain.charAt(0).toUpperCase() + this.board[unit.row][unit.col].terrain.slice(1)}
                ${this.board[unit.row][unit.col].terrain === 'forest' ? '<span style="color:#2ecc71;">(+5 Defense)</span>' : ''}
            </div>
        `;
        unitInfo.style.display = 'block';
    }

    hideUnitInfo() {
        const unitInfo = document.getElementById('unitInfo');
        unitInfo.style.display = 'none';
        unitInfo.style.position = '';
        unitInfo.style.left = '';
        unitInfo.style.right = '';
        unitInfo.style.top = '';
    }

    // Add deployment selection logic
    deployMode = false;
    deployTiles = [];
    pendingDeployType = null;
    pendingDeployPlayer = null;

    showDeployTiles(playerId, unitType) {
        // Find base
        const base = this.players[playerId].buildings.find(b => b.type === 'base');
        if (!base) return;
        this.deployTiles = [];
        // Adjacent tiles to base
        const directions = [[-1,0],[1,0],[0,-1],[0,1]];
        for (const [dr, dc] of directions) {
            const row = base.row + dr;
            const col = base.col + dc;
            if (this.isValidPosition(row, col) && !this.board[row][col].unit && !this.board[row][col].building) {
                this.deployTiles.push({row, col});
                this.board[row][col].element.classList.add('move-target');
            }
        }
        this.deployMode = true;
        this.pendingDeployType = unitType;
        this.pendingDeployPlayer = playerId;
        this.setStatus("Select a tile next to your HQ to deploy your unit.");
    }
}
//I wish there was a fix to this mess for just an AI.
    handleTileClick(row, col) ;{
        // Prevent interaction with fogged tiles (only allow on visible, not explored)
        if (this.fog[row][col] !== 1) return;
const game = new TileCraftGame(); {
        if (this.gameState !== 'playing') return;
        this.deployMode = true;
        this.pendingDeployType = unitType;
        this.pendingDeployPlayer = playerId;
        this.setStatus("Select a tile next to your HQ to deploy your unit.");
    }
}
const game = new TileCraftGame(); {
        if (this.gameState !== 'playing') return;

        const tile = this.board[row][col];

        // Deployment mode
        if (this.deployMode) {
            if (this.deployTiles.some(t => t.row === row && t.col === col)) {
                this.createUnit(this.pendingDeployType, this.pendingDeployPlayer, row, col);
                this.players[this.pendingDeployPlayer].resources -= 50;
                this.players[this.pendingDeployPlayer].recruitedThisTurn = true;
                this.deployMode = false;
                this.deployTiles = [];
                this.pendingDeployType = null;
                this.pendingDeployPlayer = null;
                this.render();
                this.updateUI();
                this.setStatus(`${this.players[this.currentPlayer].name} deployed a unit!`);
            }
            // Clear deploy highlights if clicked elsewhere
            return;
        }

        // If clicking on a move target
        if (this.moveTargets.some(t => t.row === row && t.col === col)) {
            this.moveUnit(this.selectedUnit, row, col);
            return;
        }

        // If clicking on an attack target
        if (this.attackTargets.some(t => t.row === row && t.col === col)) {
            this.attackUnit(this.selectedUnit, tile.unit);
            return;
        }

        // Clear previous selection
        this.clearSelection();

        // Select unit if it belongs to current player
        if (tile.unit && tile.unit.player === this.currentPlayer) {
            this.selectUnit(tile.unit, row, col);
        } else if (tile.unit && tile.unit.player !== this.currentPlayer) {
                       this.setStatus("You can't select the other player's unit!");
        } else {
            this.setStatus("Click your unit to select it.");
        }
        endTurn() ;{
        // Only allow if it's this player's turn
        if (this.currentPlayer !== playerId || this.gameState !== 'playing') {
            this.setStatus("It's not your turn!");
            return;
        }
    }

    recruitUnit(playerId) ;{
        if (this.gameState !== 'playing') return;
        // Only allow if it's this player's turn
        if (this.currentPlayer !== playerId || this.gameState !== 'playing') {
            this.setStatus("It's not your turn!");
            return;
        }
        // Check cooldown
        if (this.players[playerId].recruitedThisTurn) {
            this.setStatus("You can only recruit once per turn!");
            return;
        }
        // Set cost and type
        const unitType = playerId === 0 ? 'BRG' : 'UFS RW';
        const cost = 50;
        if (this.players[playerId].resources < cost) {
            this.setStatus("Not enough resources!");
            return;
        }
        // Find base position
        const base = this.players[playerId].buildings.find(b => b.type === 'base');
        if (!base || base.player !== playerId) {
            this.setStatus("You can't recruit from a captured HQ!");
            return;
        }
        // Show deploy tiles instead of auto-spawn
        this.showDeployTiles(playerId, unitType);
    }

    setupEventListeners() ;{
        document.getElementById('endTurnBtn').addEventListener('click', () => {
            if (this.gameState === 'playing' && (!this.isAIGame || this.currentPlayer === 0)) {
                this.endTurn();
            }
        });

        document.getElementById('newGameBtn').addEventListener('click', () => {
            this.isAIGame = false;
            this.gameState = 'playing';
            this.currentPlayer = 0;
            this.createBoard();
            this.createPlayers();
            this.placeInitialUnits();
            this.updateFog(); // Ensure fog is set for current player at game start
            this.render();
            this.updateUI();
            this.setStatus('New game started! Player 1 begins.');
        });

        // Add AI game button listener
        document.getElementById('aiGameBtn').addEventListener('click', () => {
            this.startAIGame();
        });

        // Add AI vs AI game button listener
        document.getElementById('aiVsAiBtn').addEventListener('click', () => {
            this.startAIVsAIGame();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            if (confirm('Are you sure you want to reset the game?')) {
                this.isAIGame = false;
                this.gameState = 'playing';
                this.currentPlayer = 0;
                // Always regenerate board and terrain
                this.createBoard();
                this.createPlayers();
                this.placeInitialUnits();
                this.render();
                this.updateUI();
                this.setStatus('Game reset! Player 1 begins.');
            }
        });

        document.getElementById('attackBtn').addEventListener('click', () => {
            if (this.selectedUnit && this.attackTargets.length > 0) {
                // Attack the first available attack target
                const target = this.attackTargets[0];
                const tile = this.board[target.row][target.col];
                this.attackUnit(this.selectedUnit, tile.unit);
            }
        });

        document.getElementById('recruitP1Btn').addEventListener('click', () => {
            this.recruitUnit(0);
        });
        document.getElementById('recruitP2Btn').addEventListener('click', () => {
            this.recruitUnit(1);
        });
    }

    startAIGame() ;{
        // Reset game state
        this.isAIGame = true;
        this.isAIVsAI = false;
        this.gameState = 'playing';
        this.currentPlayer = 0;
        this.aiThinking = false;

        // Initialize game
        this.createBoard();
        this.createPlayers();
        this.placeInitialUnits();
        
        // Configure AI player
        this.players[1].name = 'AI';
        
        // Initialize fog and render
        this.updateFog();
        this.render();
        this.updateUI();
        this.setStatus('AI Game started! You are Player 1 (Blue), AI is Player 2 (Red).');
        
        // Trigger AI turn if AI starts first
        if (this.currentPlayer === 1) {
            setTimeout(() => this.makeAIMove(), 1000);
        }
    }

    startAIVsAIGame() ;{
        // Reset game state
        this.isAIGame = true;
        this.isAIVsAI = true;
        this.gameState = 'playing';
        this.currentPlayer = 0;
        this.aiThinking = false;

        // Initialize game
        this.createBoard();
        this.createPlayers();
        this.placeInitialUnits();
        
        // Configure both players as AI
        this.players[0].name = 'AI Blue';
        this.players[1].name = 'AI Red';
        
        // Disable manual controls
        document.getElementById('endTurnBtn').disabled = true;
        document.getElementById('recruitP1Btn').disabled = true;
        document.getElementById('recruitP2Btn').disabled = true;
        
        // Remove fog for spectating
        this.fog = Array.from({length:8}, () => Array(10).fill(1));
        this.render();
        this.updateUI();
        
        // Start AI battle
        this.setStatus('AI vs AI battle started! Watch the battle unfold.');
        setTimeout(() => this.runAIVsAIBattle(), 1000);
    }

    runAIVsAIBattle() ;{
        if (!this.isAIVsAI || this.gameState !== 'playing') return;

        this.setStatus(`${this.players[this.currentPlayer].name} is thinking...`);
        setTimeout(() => {
            this.executeAITurn();
            if (this.gameState === 'playing') {
                this.endTurn();
            }
        }, 1000);
    }

    makeAIMove() ;{
        if (!this.isAIGame || this.currentPlayer !== 1 || this.gameState !== 'playing') return;
        
        this.setStatus('AI is thinking...');
        this.aiThinking = true;

        setTimeout(() => {
            this.executeAITurn();
            this.aiThinking = false;
            
            if (this.gameState === 'playing') {
                this.endTurn();
            }
        }, 1000);
    }

    // --- Improved AI logic ---
    executeAITurn() ;{
        const currentPlayer = this.players[this.currentPlayer];
        const enemyPlayer = this.players[this.currentPlayer === 0 ? 1 : 0];

        // Defensive: If HQ is threatened, move units to block/counter
        const aiBase = currentPlayer.buildings.find(b => b.type === 'base');
        let baseThreat = false;
        if (aiBase) {
            for (const enemyUnit of enemyPlayer.units) {
                if (Math.abs(enemyUnit.row - aiBase.row) + Math.abs(enemyUnit.col - aiBase.col) <= 2) {
                    baseThreat = true;
                    break;
                }
            }
        }

        // 1. Attack: Prioritize attacking units that threaten HQ or are weak
        for (const unit of currentPlayer.units) {
            if (unit.acted && !(unit.maxAttacksPerTurn > 1 && unit.attacksThisTurn < unit.maxAttacksPerTurn)) continue;
            const attackTargets = this.getPossibleAttacks(unit);
            if (attackTargets.length > 0) {
                // Prefer attacking units near AI base, then lowest health
                let bestTarget = null;
                let bestScore = -Infinity;
                for (const target of attackTargets) {
                    const enemyUnit = this.board[target.row][target.col].unit;
                    let score = 0;
                    if (aiBase) {
                        // Threat to base gets high score
                        score -= Math.abs(enemyUnit.row - aiBase.row) + Math.abs(enemyUnit.col - aiBase.col) <= 2 ? 100 : 0;
                    }
                    score -= enemyUnit.health; // Prefer low health
                    score += enemyUnit.attack; // Prefer high attack units
                    if (score > bestScore) {
                        bestScore = score;
                        bestTarget = enemyUnit;
                    }
                }
                if (bestTarget) {
                    this.attackUnit(unit, bestTarget);
                    return; // Only one attack per AI turn for realism
                }
            }
        }

        // 2. Capture: Move units onto neutral or enemy resource nodes if possible
        for (const unit of currentPlayer.units) {
            if (unit.moved) continue;
            const moveTargets = this.getPossibleMoves(unit);
            let bestMove = null;
            for (const move of moveTargets) {
                const tile = this.board[move.row][move.col];
                if (tile.building && tile.building.type === 'resource' && tile.building.player !== 1) {
                    bestMove = move;
                    break;
                }
                // Try to move onto enemy HQ if possible
                if (tile.building && tile.building.type === 'base' && tile.building.player !== 1) {
                    bestMove = move;
                    break;
                }
            }
            if (bestMove) {
                this.moveUnit(unit, bestMove.row, bestMove.col);
                return;
            }
        }

        // 3. Recruit: If resources and space, recruit near base if not threatened
        if (currentPlayer.resources >= 50 && !currentPlayer.recruitedThisTurn && aiBase) {
            const directions = [[-1,0],[1,0],[0,-1],[0,1]];
            let validTiles = [];
            for (const [dr, dc] of directions) {
                const row = aiBase.row + dr;
                const col = aiBase.col + dc;
                if (this.isValidPosition(row, col) && !this.board[row][col].unit && !this.board[row][col].building) {
                    validTiles.push({row, col});
                }
            }
            if (validTiles.length > 0) {
                // Prefer tile closest to enemy units
                let bestTile = validTiles[0];
                let minDist = Infinity;
                for (const tile of validTiles) {
                    let dist = Infinity;
                    for (const enemyUnit of enemyPlayer.units) {
                        dist = Math.min(dist, Math.abs(tile.row - enemyUnit.row) + Math.abs(tile.col - enemyUnit.col));
                    }
                    if (dist < minDist) {
                        minDist = dist;
                        bestTile = tile;
                    }
                }
                this.createUnit('UFS RW', 1, bestTile.row, bestTile.col);
                currentPlayer.resources -= 50;
                currentPlayer.recruitedThisTurn = true;
                this.setStatus("AI recruited a unit.");
                this.render();
                this.updateUI();
                return;
            }
        }

        // 4. Move: Advance units toward closest enemy or resource node, avoid water
        for (const unit of currentPlayer.units) {
            if (unit.moved) continue;
            const moveTargets = this.getPossibleMoves(unit);
            if (moveTargets.length > 0) {
                // Prefer moving toward closest enemy unit
                let bestMove = null;
                let bestDist = Infinity;
                for (const move of moveTargets) {
                    for (const enemyUnit of enemyPlayer.units) {
                        const dist = Math.abs(move.row - enemyUnit.row) + Math.abs(move.col - enemyUnit.col);
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestMove = move;
                        }
                    }
                }
                // If no enemy units, move toward nearest resource node
                if (!bestMove) {
                    for (const move of moveTargets) {
                        for (let row = 0; row < 8; row++) {
                            for (let col = 0; col < 10; col++) {
                                const tile = this.board[row][col];
                                if (tile.building && tile.building.type === 'resource' && tile.building.player !== 1) {
                                    const dist = Math.abs(move.row - row) + Math.abs(move.col - col);
                                    if (dist < bestDist) {
                                        bestDist = dist;
                                        bestMove = move;
                                    }
                                }
                            }
                        }
                    }
                }
                if (bestMove) {
                    this.moveUnit(unit, bestMove.row, bestMove.col);
                    return;
                }
            }
        }

        // If nothing to do, just end turn
    }

    checkGameOver() ;{
        for (let i = 0; i < this.players.length; i++) {
            if (this.players[i].units.length === 0) {
                this.gameState = 'gameOver';
                const winner = this.players[1 - i];
                this.setStatus(`🎉 ${winner.name} wins! 🎉`);
                return true;
            }
        }
        return false;
    }

    isValidPosition(row, col) ;{
        return row >= 0 && row < 8 && col >= 0 && col < 10;
    }

    render() ;{
        // Ensure AI vs AI mode has no fog before rendering
        if (this.isAIVsAI) {
            this.fog = Array.from({length:8}, () => Array(10).fill(1));
        }

        // Clear all tiles
        document.querySelectorAll('.tile').forEach(tile => {
            tile.innerHTML = '';
            tile.className = 'tile';
        });

        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 10; col++) {
                const tile = this.board[row][col];
                // Fog logic
                if (this.fog[row][col] === 0) {
                    tile.element.className = `tile fog`;
                    tile.element.innerHTML = '';
                    continue;
                }
                if (this.fog[row][col] === 2) {
                    tile.element.className = `tile fog`;
                    tile.element.style.opacity = "0.4";
                    tile.element.innerHTML = '';
                    tile.element.textContent = tile.terrain.charAt(0).toUpperCase();
                    continue;
                }
                tile.element.className = `tile ${tile.terrain}`;
                tile.element.style.opacity = "";
                tile.element.innerHTML = '';
                
                if (tile.building) {
                    const buildingElement = document.createElement('div');
                    buildingElement.className = `building ${tile.building.player !== null ? this.players[tile.building.player].color : 'neutral'}`;
                    buildingElement.textContent = tile.building.symbol;
                    // Show capture progress bar if being captured
                    if ((tile.building.type === 'base' || tile.building.type === 'resource') && tile.building.captureProgress > 0) {
                        const progressBar = document.createElement('div');
                        progressBar.style.position = 'absolute';
                        progressBar.style.bottom = '2px';
                        progressBar.style.left = '5px';
                        progressBar.style.width = '50px';
                        progressBar.style.height = '6px';
                        progressBar.style.background = '#333';
                        progressBar.style.borderRadius = '3px';
                        const fill = document.createElement('div');
                        fill.style.height = '100%';
                        fill.style.width = `${tile.building.captureProgress * 50 / 2}px`; // 2 turns to capture
                        fill.style.background = '#f39c12';
                        fill.style.borderRadius = '3px';
                        progressBar.appendChild(fill);
                        buildingElement.appendChild(progressBar);
                    }
                    tile.element.appendChild(buildingElement);
                }
                
                if (tile.unit) {
                    const unitElement = document.createElement('div');
                    unitElement.className = `unit ${this.players[tile.unit.player].color}`;
                    unitElement.textContent = tile.unit.symbol;
                    
                    // Add health bar
                    const healthBar = document.createElement('div');
                    healthBar.className = 'health-bar';
                    const healthFill = document.createElement('div');
                    healthFill.className = 'health-fill';
                    healthFill.style.width = `${(tile.unit.health / tile.unit.maxHealth) * 100}%`;
                    healthBar.appendChild(healthFill);
                    unitElement.appendChild(healthBar);
                    
                    tile.element.appendChild(unitElement);
                }
            }
        }
    }

    updateUI() ;{
        document.getElementById('current-turn').textContent = `${this.players[this.currentPlayer].name}'s Turn`;
        document.getElementById('p1-resources').textContent = this.players[0].resources;
        document.getElementById('p2-resources').textContent = this.players[1].resources;
        document.getElementById('p1-units').textContent = this.players[0].units.length;
        document.getElementById('p2-units').textContent = this.players[1].units.length;
        document.getElementById('turn-counter').textContent = this.turnCount;
        // Show resource node count
        document.getElementById('p1-nodes').textContent = this.players[0].buildings.filter(b => b.type === 'resource').length;
        document.getElementById('p2-nodes').textContent = this.players[1].buildings.filter(b => b.type === 'resource').length;

        // Show only the current player's recruit button
        document.getElementById('recruitP1Container').style.display = this.currentPlayer === 0 ? 'inline' : 'none';
        document.getElementById('recruitP2Container').style.display = this.currentPlayer === 1 ? 'inline' : 'none';

        // Disable recruit button if on cooldown
        if (this.currentPlayer === 0) {
            document.getElementById('recruitP1Btn').disabled = this.players[0].recruitedThisTurn;
            document.getElementById('recruitP1Btn').textContent = this.players[0].recruitedThisTurn
                ? 'Recruit Blue Republic Gunner (Cooldown)'
                : 'Recruit Blue Republic Gunner (50)';
        } else {
            document.getElementById('recruitP2Btn').disabled = this.players[1].recruitedThisTurn;
            document.getElementById('recruitP2Btn').textContent = this.players[1].recruitedThisTurn
                ? 'Recruit Red War (Cooldown)'
                : 'Recruit Red War (50)';
        }
    }

    updateActionButtons() ;{
        const attackBtn = document.getElementById('attackBtn');
        const hasSelection = this.selectedUnit !== null;
        const canMove = hasSelection && !this.selectedUnit.moved && this.moveTargets.length > 0;
        const canAttack = hasSelection &&
            (!this.selectedUnit.acted ||
            (this.selectedUnit.maxAttacksPerTurn > 1 && this.selectedUnit.attacksThisTurn < this.selectedUnit.maxAttacksPerTurn))
            && this.attackTargets.length > 0;
        attackBtn.disabled = !canAttack;
        // ...removed ambushBtn logic comment...
    }

    showUnitInfo(unit) ;{
        // Only show info if tile is visible
        if (this.fog[unit.row][unit.col] !== 1) return;

        const unitInfo = document.getElementById('unitInfo');
        // Determine which side to display info based on HQ position
        let base = this.players[unit.player].buildings.find(b => b.type === 'base');
        let side = 'left';
        if (base && base.col > 4) side = 'right';

        // Position the info panel accordingly
        unitInfo.style.position = 'absolute';
        unitInfo.style.top = '120px';
        unitInfo.style[side] = '40px';
        unitInfo.style[side === 'left' ? 'right' : 'left'] = 'auto';

        // Refined stat system
        let stats = [
            { label: 'Health', value: `${unit.health}/${unit.maxHealth}` },
            { label: 'Movement', value: unit.movement },
            { label: 'Attack', value: unit.attack },
            { label: 'Range', value: unit.range || 1 },
            { label: 'Special', value: unit.canDoubleAttack ? 'Double Attack' : unit.canAmbush ? 'Ambush' : 'None' }
        ];

        unitInfo.innerHTML = `
            <h3>${unit.name}</h3>
            <p style="font-size:14px;">${unit.description}</p>
            <table style="margin:0 auto;text-align:left;">
                ${stats.map(s => `<tr><td><b>${s.label}:</b></td><td>${s.value}</td></tr>`).join('')}
            </table>
            <div style="margin-top:8px;">
                Terrain: ${this.board[unit.row][unit.col].terrain.charAt(0).toUpperCase() + this.board[unit.row][unit.col].terrain.slice(1)}
                ${this.board[unit.row][unit.col].terrain === 'forest' ? '<span style="color:#2ecc71;">(+5 Defense)</span>' : ''}
            </div>
        `;
        unitInfo.style.display = 'block';
    }

    hideUnitInfo() ;{
        const unitInfo = document.getElementById('unitInfo');
        unitInfo.style.display = 'none';
        unitInfo.style.position = '';
        unitInfo.style.left = '';
        unitInfo.style.right = '';
        unitInfo.style.top = '';
    }

    // Add deployment selection logic
    deployMode = false;
    deployTiles = [];
    pendingDeployType = null;
    pendingDeployPlayer = null;

    showDeployTiles(playerId, unitType) ;{
        // Find base
        const base = this.players[playerId].buildings.find(b => b.type === 'base');
        if (!base) return;
        this.deployTiles = [];
        // Adjacent tiles to base
        const directions = [[-1,0],[1,0],[0,-1],[0,1]];
        for (const [dr, dc] of directions) {
            const row = base.row + dr;
            const col = base.col + dc;
            if (this.isValidPosition(row, col) && !this.board[row][col].unit && !this.board[row][col].building) {
                this.deployTiles.push({row, col});
                this.board[row][col].element.classList.add('move-target');
            }
        }
        this.deployMode = true;
        this.pendingDeployType = unitType;
        this.pendingDeployPlayer = playerId;
        this.setStatus("Select a tile next to your HQ to deploy your unit.");
    }
}
//I wished I knew coding right now as this f**king a mess as I'm typing this.
const gameState = new TileCraftGame(); [
            { label: 'Health', value: `${unit.health}/${unit.maxHealth}` },
            { label: 'Movement', value: unit.movement },
            { label: 'Attack', value: unit.attack },
            { label: 'Range', value: unit.range || 1 },
            { label: 'Special', value: unit.canDoubleAttack ? 'Double Attack' : unit.canAmbush ? 'Ambush' : 'None' }
        ];
        gameState.push({
            unitId: unit.id,
            stats: stats
        });
        {
        unitInfo.innerHTML = `
            <h3>${unit.name}</h3>
            <p style="font-size:14px;">${unit.description}</p>
            <table style="margin:0 auto;text-align:left;">
                ${stats.map(s => `<tr><td><b>${s.label}:</b></td><td>${s.value}</td></tr>`).join('')}
            </table>
            <div style="margin-top:8px;">
                Terrain: ${this.board[unit.row][unit.col].terrain.charAt(0).toUpperCase() + this.board[unit.row][unit.col].terrain.slice(1)}
                ${this.board[unit.row][unit.col].terrain === 'forest' ? '<span style="color:#2ecc71;">(+5 Defense)</span>' : ''}
            </div>
        `;
        unitInfo.style.display = 'block';
    }

    hideUnitInfo() ;{
        const unitInfo = document.getElementById('unitInfo');
        unitInfo.style.display = 'none';
        unitInfo.style.position = '';
        unitInfo.style.left = '';
        unitInfo.style.right = '';
        unitInfo.style.top = '';
    }
{
    // Add deployment selection logic
    deployMode = false;
    deployTiles = [];
    pendingDeployType = null;
    pendingDeployPlayer = null;

    showDeployTiles(playerId, unitType) ;{
        // Find base
        const base = this.players[playerId].buildings.find(b => b.type === 'base');
        if (!base) return;
        this.deployTiles = [];
        // Adjacent tiles to base
        const directions = [[-1,0],[1,0],[0,-1],[0,1]];
        for (const [dr, dc] of directions) {
            const row = base.row + dr;
            const col = base.col + dc;
            if (this.isValidPosition(row, col) && !this.board[row][col].unit && !this.board[row][col].building) {
                this.deployTiles.push({row, col});
                this.board[row][col].element.classList.add('move-target');
            }
        }
        this.deployMode = true;
        this.pendingDeployType = unitType;
        this.pendingDeployPlayer = playerId;
        this.setStatus("Select a tile next to your HQ to deploy your unit.");
        // Only allow if it's this player's turn
    }
}
const actionPanel = new TileCraftGame();
    </script>
</body>
</html>
